/* AUTOGENERATED FILE, DO NOT EDIT */

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/.
 */

#include "evoasm-x64.h"

static const char *_evoasm_log_tag = "x64";

evoasm_success_t
evoasm_x64_get_features(uint64_t *features_) {
  evoasm_buf_t buf_;
  evoasm_buf_t *buf = &buf_;
  evoasm_x64_params_t params = {0};
  bool retval = true;
  uint64_t features = 0;

  uint32_t vals[3][2] = {0};

  evoasm_log_debug("Running CPUID...");

  EVOASM_TRY(alloc_failed, evoasm_buf_init, buf, EVOASM_BUF_TYPE_MMAP, 512);
  EVOASM_TRY(enc_failed, evoasm_x64_emit_func_prolog, EVOASM_X64_ABI_SYSV, buf);


  EVOASM_X64_SET(EVOASM_X64_PARAM_REG0, EVOASM_X64_REG_A);
  EVOASM_X64_SET(EVOASM_X64_PARAM_IMM0, 1);
  EVOASM_X64_ENC(mov_r32_imm32);


  EVOASM_X64_ENC(cpuid);


  {
    int64_t addr_imm;
    addr_imm = (int64_t)(uintptr_t) &vals[0][0];
    EVOASM_X64_SET(EVOASM_X64_PARAM_REG0, EVOASM_X64_REG_DI);
    EVOASM_X64_SET(EVOASM_X64_PARAM_IMM0, addr_imm);
    EVOASM_X64_ENC(mov_r64_imm64);

    EVOASM_X64_SET(EVOASM_X64_PARAM_REG1, EVOASM_X64_REG_D);
    EVOASM_X64_SET(EVOASM_X64_PARAM_REG_BASE, EVOASM_X64_REG_DI);
    EVOASM_X64_ENC(mov_rm32_r32);
    EVOASM_X64_UNSET(EVOASM_X64_PARAM_ADDR_SIZE);
    EVOASM_X64_UNSET(EVOASM_X64_PARAM_REG_BASE);

  }

  {
    int64_t addr_imm;
    addr_imm = (int64_t)(uintptr_t) &vals[0][1];
    EVOASM_X64_SET(EVOASM_X64_PARAM_REG0, EVOASM_X64_REG_DI);
    EVOASM_X64_SET(EVOASM_X64_PARAM_IMM0, addr_imm);
    EVOASM_X64_ENC(mov_r64_imm64);

    EVOASM_X64_SET(EVOASM_X64_PARAM_REG1, EVOASM_X64_REG_C);
    EVOASM_X64_SET(EVOASM_X64_PARAM_REG_BASE, EVOASM_X64_REG_DI);
    EVOASM_X64_ENC(mov_rm32_r32);
    EVOASM_X64_UNSET(EVOASM_X64_PARAM_ADDR_SIZE);
    EVOASM_X64_UNSET(EVOASM_X64_PARAM_REG_BASE);

  }

  EVOASM_X64_SET(EVOASM_X64_PARAM_REG0, EVOASM_X64_REG_A);
  EVOASM_X64_SET(EVOASM_X64_PARAM_IMM0, 7);
  EVOASM_X64_ENC(mov_r32_imm32);

  EVOASM_X64_SET(EVOASM_X64_PARAM_REG0, EVOASM_X64_REG_C);
  EVOASM_X64_SET(EVOASM_X64_PARAM_IMM0, 0);
  EVOASM_X64_ENC(mov_r32_imm32);

  EVOASM_X64_ENC(cpuid);


  {
    int64_t addr_imm;
    addr_imm = (int64_t)(uintptr_t) &vals[1][0];
    EVOASM_X64_SET(EVOASM_X64_PARAM_REG0, EVOASM_X64_REG_DI);
    EVOASM_X64_SET(EVOASM_X64_PARAM_IMM0, addr_imm);
    EVOASM_X64_ENC(mov_r64_imm64);

    EVOASM_X64_SET(EVOASM_X64_PARAM_REG1, EVOASM_X64_REG_B);
    EVOASM_X64_SET(EVOASM_X64_PARAM_REG_BASE, EVOASM_X64_REG_DI);
    EVOASM_X64_ENC(mov_rm32_r32);
    EVOASM_X64_UNSET(EVOASM_X64_PARAM_ADDR_SIZE);
    EVOASM_X64_UNSET(EVOASM_X64_PARAM_REG_BASE);

  }

  {
    int64_t addr_imm;
    addr_imm = (int64_t)(uintptr_t) &vals[1][1];
    EVOASM_X64_SET(EVOASM_X64_PARAM_REG0, EVOASM_X64_REG_DI);
    EVOASM_X64_SET(EVOASM_X64_PARAM_IMM0, addr_imm);
    EVOASM_X64_ENC(mov_r64_imm64);

    EVOASM_X64_SET(EVOASM_X64_PARAM_REG1, EVOASM_X64_REG_C);
    EVOASM_X64_SET(EVOASM_X64_PARAM_REG_BASE, EVOASM_X64_REG_DI);
    EVOASM_X64_ENC(mov_rm32_r32);
    EVOASM_X64_UNSET(EVOASM_X64_PARAM_ADDR_SIZE);
    EVOASM_X64_UNSET(EVOASM_X64_PARAM_REG_BASE);

  }

  EVOASM_X64_SET(EVOASM_X64_PARAM_REG0, EVOASM_X64_REG_A);
  EVOASM_X64_SET(EVOASM_X64_PARAM_IMM0, 2147483649);
  EVOASM_X64_ENC(mov_r32_imm32);


  EVOASM_X64_ENC(cpuid);


  {
    int64_t addr_imm;
    addr_imm = (int64_t)(uintptr_t) &vals[2][0];
    EVOASM_X64_SET(EVOASM_X64_PARAM_REG0, EVOASM_X64_REG_DI);
    EVOASM_X64_SET(EVOASM_X64_PARAM_IMM0, addr_imm);
    EVOASM_X64_ENC(mov_r64_imm64);

    EVOASM_X64_SET(EVOASM_X64_PARAM_REG1, EVOASM_X64_REG_D);
    EVOASM_X64_SET(EVOASM_X64_PARAM_REG_BASE, EVOASM_X64_REG_DI);
    EVOASM_X64_ENC(mov_rm32_r32);
    EVOASM_X64_UNSET(EVOASM_X64_PARAM_ADDR_SIZE);
    EVOASM_X64_UNSET(EVOASM_X64_PARAM_REG_BASE);

  }

  {
    int64_t addr_imm;
    addr_imm = (int64_t)(uintptr_t) &vals[2][1];
    EVOASM_X64_SET(EVOASM_X64_PARAM_REG0, EVOASM_X64_REG_DI);
    EVOASM_X64_SET(EVOASM_X64_PARAM_IMM0, addr_imm);
    EVOASM_X64_ENC(mov_r64_imm64);

    EVOASM_X64_SET(EVOASM_X64_PARAM_REG1, EVOASM_X64_REG_C);
    EVOASM_X64_SET(EVOASM_X64_PARAM_REG_BASE, EVOASM_X64_REG_DI);
    EVOASM_X64_ENC(mov_rm32_r32);
    EVOASM_X64_UNSET(EVOASM_X64_PARAM_ADDR_SIZE);
    EVOASM_X64_UNSET(EVOASM_X64_PARAM_REG_BASE);

  }

  EVOASM_TRY(enc_failed, evoasm_x64_emit_func_epilog, EVOASM_X64_ABI_SYSV, buf);

  /*evoasm_buf_dump(buf, stderr);*/

  EVOASM_TRY(enc_failed, evoasm_buf_protect, buf, EVOASM_MPROT_MODE_RX);
  evoasm_buf_exec(buf);

  if(vals[0][0] & (1ull << 8)) {
    features |= (1ull << EVOASM_X64_FEATURE_CX8);
    evoasm_log_info("Found support for CX8");
  } else {
    evoasm_log_info("Missing support for CX8");
  }
  if(vals[0][0] & (1ull << 15)) {
    features |= (1ull << EVOASM_X64_FEATURE_CMOV);
    evoasm_log_info("Found support for CMOV");
  } else {
    evoasm_log_info("Missing support for CMOV");
  }
  if(vals[0][0] & (1ull << 23)) {
    features |= (1ull << EVOASM_X64_FEATURE_MMX);
    evoasm_log_info("Found support for MMX");
  } else {
    evoasm_log_info("Missing support for MMX");
  }
  if(vals[0][0] & (1ull << 25)) {
    features |= (1ull << EVOASM_X64_FEATURE_SSE);
    evoasm_log_info("Found support for SSE");
  } else {
    evoasm_log_info("Missing support for SSE");
  }
  if(vals[0][0] & (1ull << 26)) {
    features |= (1ull << EVOASM_X64_FEATURE_SSE2);
    evoasm_log_info("Found support for SSE2");
  } else {
    evoasm_log_info("Missing support for SSE2");
  }
  if(vals[0][1] & (1ull << 0)) {
    features |= (1ull << EVOASM_X64_FEATURE_SSE3);
    evoasm_log_info("Found support for SSE3");
  } else {
    evoasm_log_info("Missing support for SSE3");
  }
  if(vals[0][1] & (1ull << 1)) {
    features |= (1ull << EVOASM_X64_FEATURE_PCLMULQDQ);
    evoasm_log_info("Found support for PCLMULQDQ");
  } else {
    evoasm_log_info("Missing support for PCLMULQDQ");
  }
  if(vals[0][1] & (1ull << 9)) {
    features |= (1ull << EVOASM_X64_FEATURE_SSSE3);
    evoasm_log_info("Found support for SSSE3");
  } else {
    evoasm_log_info("Missing support for SSSE3");
  }
  if(vals[0][1] & (1ull << 12)) {
    features |= (1ull << EVOASM_X64_FEATURE_FMA);
    evoasm_log_info("Found support for FMA");
  } else {
    evoasm_log_info("Missing support for FMA");
  }
  if(vals[0][1] & (1ull << 13)) {
    features |= (1ull << EVOASM_X64_FEATURE_CX16);
    evoasm_log_info("Found support for CX16");
  } else {
    evoasm_log_info("Missing support for CX16");
  }
  if(vals[0][1] & (1ull << 19)) {
    features |= (1ull << EVOASM_X64_FEATURE_SSE4_1);
    evoasm_log_info("Found support for SSE4_1");
  } else {
    evoasm_log_info("Missing support for SSE4_1");
  }
  if(vals[0][1] & (1ull << 20)) {
    features |= (1ull << EVOASM_X64_FEATURE_SSE4_2);
    evoasm_log_info("Found support for SSE4_2");
  } else {
    evoasm_log_info("Missing support for SSE4_2");
  }
  if(vals[0][1] & (1ull << 22)) {
    features |= (1ull << EVOASM_X64_FEATURE_MOVBE);
    evoasm_log_info("Found support for MOVBE");
  } else {
    evoasm_log_info("Missing support for MOVBE");
  }
  if(vals[0][1] & (1ull << 23)) {
    features |= (1ull << EVOASM_X64_FEATURE_POPCNT);
    evoasm_log_info("Found support for POPCNT");
  } else {
    evoasm_log_info("Missing support for POPCNT");
  }
  if(vals[0][1] & (1ull << 25)) {
    features |= (1ull << EVOASM_X64_FEATURE_AES);
    evoasm_log_info("Found support for AES");
  } else {
    evoasm_log_info("Missing support for AES");
  }
  if(vals[0][1] & (1ull << 28)) {
    features |= (1ull << EVOASM_X64_FEATURE_AVX);
    evoasm_log_info("Found support for AVX");
  } else {
    evoasm_log_info("Missing support for AVX");
  }
  if(vals[0][1] & (1ull << 29)) {
    features |= (1ull << EVOASM_X64_FEATURE_F16C);
    evoasm_log_info("Found support for F16C");
  } else {
    evoasm_log_info("Missing support for F16C");
  }
  if(vals[1][0] & (1ull << 3)) {
    features |= (1ull << EVOASM_X64_FEATURE_BMI1);
    evoasm_log_info("Found support for BMI1");
  } else {
    evoasm_log_info("Missing support for BMI1");
  }
  if(vals[1][0] & (1ull << 5)) {
    features |= (1ull << EVOASM_X64_FEATURE_AVX2);
    evoasm_log_info("Found support for AVX2");
  } else {
    evoasm_log_info("Missing support for AVX2");
  }
  if(vals[1][0] & (1ull << 8)) {
    features |= (1ull << EVOASM_X64_FEATURE_BMI2);
    evoasm_log_info("Found support for BMI2");
  } else {
    evoasm_log_info("Missing support for BMI2");
  }
  if(vals[1][0] & (1ull << 11)) {
    features |= (1ull << EVOASM_X64_FEATURE_RTM);
    evoasm_log_info("Found support for RTM");
  } else {
    evoasm_log_info("Missing support for RTM");
  }
  if(vals[1][0] & (1ull << 18)) {
    features |= (1ull << EVOASM_X64_FEATURE_RDSEED);
    evoasm_log_info("Found support for RDSEED");
  } else {
    evoasm_log_info("Missing support for RDSEED");
  }
  if(vals[1][0] & (1ull << 19)) {
    features |= (1ull << EVOASM_X64_FEATURE_ADX);
    evoasm_log_info("Found support for ADX");
  } else {
    evoasm_log_info("Missing support for ADX");
  }
  if(vals[1][0] & (1ull << 23)) {
    features |= (1ull << EVOASM_X64_FEATURE_CLFLUSHOPT);
    evoasm_log_info("Found support for CLFLUSHOPT");
  } else {
    evoasm_log_info("Missing support for CLFLUSHOPT");
  }
  if(vals[1][0] & (1ull << 28)) {
    features |= (1ull << EVOASM_X64_FEATURE_SHA);
    evoasm_log_info("Found support for SHA");
  } else {
    evoasm_log_info("Missing support for SHA");
  }
  if(vals[1][1] & (1ull << 0)) {
    features |= (1ull << EVOASM_X64_FEATURE_PREFETCHWT1);
    evoasm_log_info("Found support for PREFETCHWT1");
  } else {
    evoasm_log_info("Missing support for PREFETCHWT1");
  }
  if(vals[2][1] & (1ull << 0)) {
    features |= (1ull << EVOASM_X64_FEATURE_LAHF_LM);
    evoasm_log_info("Found support for LAHF_LM");
  } else {
    evoasm_log_info("Missing support for LAHF_LM");
  }


  *features_ = features;

cleanup:
  EVOASM_TRY(destroy_failed, evoasm_buf_destroy, buf);
  return retval;
enc_failed:
  retval = false;
  goto cleanup;
destroy_failed:
  return false;
alloc_failed:
  return false;
}

